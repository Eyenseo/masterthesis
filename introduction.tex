\documentclass[thesis]{subfiles}
\begin{document}

\chapter{Introduction}
This thesis is about the design and implementation of a \gls{skill} generator (see \autoref{sec:skill}) that targets Rust.
Through the guarantees of Rust (see \autoref{sec:rust}) the produced code will be guaranteed safe and parallelised in data-race free manner.

\section{SKilL}\label{sec:skill}
  \gls{skill}, as the name suggests, is a language that is intended to be used for serialisation.
  The next sections will give a brief overview of \gls{skill}, the tooling and its intended use.
  For more in depth information and the reasoning for design decisions it is advised to refer to \autocites{skill-tr}{skill-dis}.

  \subsection{\glsentrytext{skill} Motive}
    The motive behind \gls{skill} is to provide a serialisation method that supports the following features\autocite{skill-tr}:
    \begin{itemize}
      \item small serialised file sizes
      \item fully reflective type encoding
      \item type-safe storage of references
      \item a type system that provides container, references, single inheritance and extension points
      \item tools work with partial specifications
      \item coding that is platform and language independent, upwards and downwards compatible
      \item data that is not used will not be deserialized
    \end{itemize}

    \gls{skill} itself is a data structure description language.
    With \gls{skill} it is possible to describe the data structures for a software system in a natural way.
    This is possible since the type system provides the fundamental types that are building blocks of most, commonly used languages.
    The type system in combination with the different targets (e.g.\ C, C++, Java) allow the user to write code in the prefered or required language.

  \subsection{\glsentrytext{skill} Usage}
    After the description file is create it can be passed to the ``compiler''.
    Contrary to gcc, clang or javac the \gls{skill} compiler targets other languages like C, C++ or Java.
    To generate the target's code the first step is to translate the input to an \gls{ir}.
    That \gls{ir} is then given to a generator for further processing.
    These generators are the final step that generate the native code from the \gls{ir}.

    Generators can support different amounts of features and some features may not be native to the language e.g.\ inheritance in C.
    In such cases the generator has to produce something comparable to the intended feature.
    In case of inheritance for C, are structures declared with all fields that were specified in the super types of them in the \gls{skill} file.
    Similarly is the upwards and downwards compatibility achieved by generators.
    The basic idea is to create some kind of type erasure.
    How that is achieved depends on the target language.

    \subsection{\glsentrytext{skill} Internals}\label{sec:skillInter}
    \begin{wrapfigure}{r}{0.3\textwidth}%
      \centering
      \begin{tikzpicture}
        \tikzset{%
          node distance=1mm,
          box/.style={draw, rounded corners=.5em},%
          block/.style={box, minimum width={width("Field Meta Data")+3mm}},
          string/.style={box, minimum width={width("Lengths")+3mm}},
          type/.style={box, minimum width={width("Field Meta Data")+3mm}},
        }
        \node(name) {Skill File};
        \node[box, below=-.5em of name] {
          \begin{tikzpicture}
            \node(name) {Block \#};
            \node[box, below=of name] {
              \begin{tikzpicture}
                \node[block] (stringBlock) {
                  \begin{tikzpicture}
                    \node(name) {String Block};
                    \node[string, below=of name] (lengths) {Lengths};
                    \node[string, below=of lengths] {Strings};
                  \end{tikzpicture}
                };
                \node[block, below=of stringBlock] (typeBlock) {
                  \begin{tikzpicture}
                    \node(name) {Type Block};
                    \node[type, below=of name] (types) {Type Meta Data};
                    \node[type, below=of types] (meta) {Field Meta Data};
                    \node[type, below=of meta] {Field Data};
                  \end{tikzpicture}
                };
              \end{tikzpicture}
            };
          \end{tikzpicture}
        };
      \end{tikzpicture}
      \captionsetup{justification=raggedright}
      \caption{\gls{skill} File Layout}
      \label{img:skilllayout}
      \vspace*{-3\baselineskip}
    \end{wrapfigure}
    This section will focus on internals of \gls{skill}, meaning that de-/serialisation and runtime system will be touched.

    \subsubsection{Reading and Writing}\label{sec:rwSkill}
      As seen in \autoref{img:skilllayout} a \gls{skill} file is made up of multiple blocks\footnote{
      }.
      Each of these blocks is made up of a string block and a type block.
      String blocks first list the amount of strings, followed by the lengths of the strings followed by the strings themself.
      This layout allows for easy reading and writing of the strings with \cod{mmap}\footnote{
        \cod{mmap} allows to map files -- also file sections -- to a memory location that can be accessed like an array.
      } as well as parallelization.
      Type blocks start with the amount of types followed by the type definitions.
      These definitions are about the type only and do not contain an information about the fields of the type -- apart from the amount that is.
      In that section the number of instances, restrictions and super type are listed.
      The next section contains the field definitions for the types.
      Similar to inheritance in languages are super field definitions not redefined for the children types.
      The definition is made up of the type of the field, as well as the restrictions.
      The section ends with offsets into the next section where the data of the fields resides.\autocite{skill-tr}

      All data touched so far is comparable small and fast to read.
      It is also not much use to the user as this data is mostly relevant to the \gls{skill} runtime type system.
      The runtime type system is important to allow for types and fields that are unknown to the generated code.
      It is also important for the deletion of instances.
      Since the end of this section only holds data and all offsets are known the reading of the data can be heavily parallelised.

      The reading and writing themself are not too much different from the other implementations.
      It will therefore not be explained in more detail than in this abstract section.
      Similarly are multi-blocks more sophisticated than this section may make them out to be.
      The involved data structures and data flow however will be discussed as well as their consequences.

    \subsubsection{Runtime System}
      A few types are common to all implementations, apart from the ones that are necessary to implement the de-/serialisation.
      The \cod{SkillFile} is the \gls{api} root that the user accesses to open and create \gls{skill} files.
      Through \cod{SkillFile} instances the can access a \cod{StringPool} that is responsible to create and manage strings in such a way that they can be serialised.
      Similarly are there the \cod{TypePool}s that are responsible for the creation and management of the type instances.
      Like the type block the fields of the types are managed by \cod{FieldDeclaration}s and not the type pools themself.
      This split is not only important for the separation of concerns but also for code generation and the ability to parallelize the code.

\section{Rust}
  \label{sec:rust}
  % TODO mention
  % Like C++, Rust takes zero-cost abstractions as one of its core principles:
  % none of Rustâ€™string abstractions impose a global performance penalty, nor is
  % there overhead from any runtime system in the traditional sense.

  The official Rust language website describes the language as;
  \enquote{Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.}\autocite{rust-org}
  It presents itself mostly as a \emph{safe} language that should be considered as substitute for C, C++ and other systems programming languages.
  The project criticizes especially the following points in other languages and intends to solve them\autocite{rust-org}:
  \begin{enumerate}
    \item There is too little attention paid to safety.
    \item They have poor concurrency support.
    \item There is a lack of practical affordances.
    \item They offer limited control over resources.
  \end{enumerate}
  But the project doesn't aim to create a complete safe language and intends to make compromises in favor of other goals.
  % TODO mention Ada here?

  The following sections will provide a short introduction to the Rust programming language.
  The focus is on the elements and features that are important to this thesis and with that non exhaustive.
  For a more in-depth and up to data introduction it is strongly advised to refer to the official documentation.

  \subsection{Borrows and Lifetimes}\label{sec:rustBorr}
    At the core of the memory and concurrency goal stands the \emph{borrowing} mechanic.
    Borrowing can be thought of as \emph{taking a reference} in C++.
    Like all variables borrows are by default \emph{immutable} or in C++ words \codc{const}.
    Contrary to C++ mutable access has to be explicitly requested with the \codr{mut} keyword.
    Additionally to the reference Rust also attaches a \emph{lifetime} to the borrow.
    This lifetime can be thought of as a `reference counted`\footnote{%
      This will be a more fitting mental image once non-lexical lifetimes become stable.
    } smart-pointer \emph{at compile-time}.
    A program will fail to compile if there is more than one mutable access to a variable or a writable and readable access exists at the same time.

    \lstinputlisting[
      style=myEnvStyle,
      language=Rust,
      float,
      floatplacement=ht,
      caption={Rust Borrow Mechanics},
      label={lst:borrowing},
    ]{data/borrow_mut.rs}

    \autoref{lst:borrowing} depicts a simple example that demonstrates these rules.
    In line 2 a new \emph{owned} string is created -- \codr{"Hello"} is a string literal and can't be modified.
    Since the string shall be modified an explicit conversion function has to be called.
    An immutable borrow is taken from \codr{string} in line 2.
    It is fine to use both \codr{string} and \codr{foo} to call methods on the object that require an immutable borrow.
    But using a method that requires a mutable borrow on \codr{foo} will lead to a compile-time error.
    It might be surprising, but line 9 also leads to a compile-time error\footnote{%
      With non-lexical lifetimes this will compile.
    }.
    Since \codr{string} is borrowed immutable until the end of the scope it doesn't matter that it is a mutable variable.

    \newsavebox{\lifetimeErrBox}
    \begin{lrbox}{\lifetimeErrBox}% Store first listing
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
        ]{data/lifetime_err.rs}
      \end{minipage}
    \end{lrbox}

    \newsavebox{\lifetimeFixBox}
    \begin{lrbox}{\lifetimeFixBox}% Store first listing
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
        ]{data/lifetime_fixed.rs}
      \end{minipage}
    \end{lrbox}

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \subfloat[Explicit Lifetime Required]{\usebox{\lifetimeErrBox}\label{lst:lifetimeErr}} \hfill%
      \subfloat[Lifetime Mechanic Benefits]{\usebox{\lifetimeFixBox}\label{lst:lifetimeFix}}
      \caption{Rust Lifetime Mechanics}\label{lst:lifetime}
    \end{figure}

    In \autoref{lst:borrowing} the lifetimes can be omitted as the compiler is able to infer them.
    For \autoref{lst:lifetimeErr} an explicit lifetime is needed for the attribute \codr{s} in the struct \codr{Foo}.
    Here the compiler is not able to infer where the lifetime for \codr{s} will come from.
    In \autoref{lst:lifetimeFix} this error is fixed by explicitly giving the borrow a lifetime.
    % TODO is it really or has it a special name?
    This leads to a different compiler error that is called \emph{use after free} and can lead to dangerous situations.
    At this point it has to be noted thou that lifetimes can only be applied to borrows.
    In other words they can't be used to say something about the lifetime of memory itself.

  \subsection{Structs, Traits and Generics}\label{sec:stg}
    The fundamental pieces of the Rust \gls{oop} model are \structs, \traits and \codr{impl} blocks.
    \structs are equivalent to C \codc{struct}s as they are a collection of fields.
    \traits can be thought of as Java \codj{interface}s, they dictate a set of functions that have to be implemented by a type that provides a certain \trait.
    Additionally to \traits \codr{impl} blocks can be used to add methods to a \struct.

    While Rust can be thought of as an \gls{oop} language it differs in a few features these languages exhibit usually.
    The most apparent is the inheritance model.
    While it is not possible to inherit from a \struct, \traits can inherit each other.
    It is also possible to implement functions and \traits for a set of types through generic type parameter.
    This set of types is made up of a types that satisfy a collection of \traits and lifetimes.
    These are also called \emph{bounds} and one can be seen in line 5 of \autoref{lst:genericsCall}.
    Never the less leads the missing inheritance of \structs to `forced' composition and to code duplication if a bound can't be expressed.
    Such a situation can appear as a bound has to hold for all types, whether all types actually invoke the functions doesn't matter.
    This is in contrast to C++ where only the function invocation triggers a check for it.
    In cases like this there are macros that provide a convenient way to duplicate the code at the appropriate places.
    % TODO mention 'missing' function overloading

    \newsavebox{\genericsBase}
    \begin{lrbox}{\genericsBase}%
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
          lastline=14,
        ]{data/generics.rs}
      \end{minipage}
    \end{lrbox}

    \newsavebox{\genericsCall}
    \begin{lrbox}{\genericsCall}
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
          firstline=16,
        ]{data/generics.rs}
      \end{minipage}
    \end{lrbox}

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \subfloat[Type Structure]{\usebox{\genericsBase}\label{lst:genericsBase}} \hfill%
      \subfloat[Generics and Trait Usages]{\usebox{\genericsCall}\label{lst:genericsCall}}
      \caption{Rust Generics and Trait Objects}\label{lst:generics}
    \end{figure}

    \autoref{lst:genericsBase} declares a \trait and two \structs that then implement the \trait respectively.
    In line 1 of \autoref{lst:genericsCall} the function \codr{fun_gen} uses a type parameter \T with a bound of \codr{Who}.
    There too happens code duplication -- this time on invocation of the generic function.
    This is called \emph{monomorphism} and behaves similarly the way C++ realises template functions.
    In case that a function is not implemented for a bound, or it is not possible to do so, the alternative is a \emph{trait object}.
    This can be seen in line 5 of \autoref{lst:genericsCall} where the function expects an trait object.
    Trait objects can be compared to abstract classes in C++.
    This means that method calls are a \emph{dynamic dispatched} -- in other words a virtual function call is executed for \codr{obj.who()}.
    Since virtual function calls are generally slow it often advised to write code that is based on bounds.
    Rusts approach to virtual function calls is based on fat pointers \cod{[data_ptr, vtable_ptr]}.
    This might introduce additional slowdown as more cache is need per object.

  \subsection{Errors and Null}\label{sec:rustErr}
    For errors, failures or exceptions Rust doesn't use \emph{exceptions}\footnote{%
      This is partially true as \codr{panic}s can be caught\ldots
    }.
    Rust provides two ways to express an error, both can be seen in \autoref{lst:errorFun}.
    The first way uses the \codr{Result<T, E>} wrapper as return type of functions.
    This type contains either the success return value of type \T or an error value of type \codr{E}.
    In case the value is \codr{0} the success value will be returned.
    In case that the value is greater than \codr{7} an error value will be returned instead.
    Lastly there is \codc{panic!}\footnote{%
      The \codr{!} indicates that \codr{panic!} is a macro.
    } which will terminate the program.
    This macro is used throughout the standard library e.g.\ for an access over the limits of an array.
    Another wrapper type that is used throughout the standard library is \OptionT.
    The main difference to \codr{Result} is, that \codr{Option} can only hold a valid value or non at all.
    An wrapped value is created thought \codr{Some(val)} or \codr{None}.

    \newsavebox{\errorFun}
    \begin{lrbox}{\errorFun}%
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
          lastline=9,
        ]{data/error.rs}
      \end{minipage}
    \end{lrbox}

    \newsavebox{\errorGun}
    \begin{lrbox}{\errorGun}
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
          firstline=10,
        ]{data/error.rs}
      \end{minipage}
    \end{lrbox}

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \subfloat[Rust Error Types]{\usebox{\errorFun}\label{lst:errorFun}} \hfill%
      \subfloat[Ways to Deal with Errors]{\usebox{\errorGun}\label{lst:errorGun}}
      \caption{Rust Error Mechanics}\label{lst:error}
    \end{figure}

    \autoref{lst:errorGun} shows two ways how these wrapped values can be unwrapped though \emph{matching}.
    In \codr{gun()} it is the \codr{?} operator, which unwraps the \codr{Result}.
    If it is the success value it will be returned to the \emph{scope}.
    But if it is the error value the value will be returned from the \emph{function}.
    The \codr{?} operator is a tool to direct the data flow of possible error results conveniently.
    What the \codr{?} operator does can be roughly seen in the \codr{hun()} function.
    In case of an \codr{Option} there is a more convenient way; \codr|if let Some(val) = val { ... }|.
    Matching is can be found in many aspects of the language and is is mostly a convenience feature.

  \subsection{Tools and Ecosystem}
    Another place where Rust differentiates itself from competitors is the tooling and the resulting ecosystem.
    As a young language Rust took the opportunity to learn and improve upon the established languages.

    The build system is not a third party tool but rather an extension of Rust language itself.
    Projects are created through the \cod{cargo} command that creates a bare bones project structure and also a \cod{git} repository.
    Through \cod{cargo} builds, tests, benchmarks and publications are handled.
    The tool handles the dependencies and downloads the specific libraries from \href{www.crates.io}{crates.io} which is something that other systems languages struggle with.
    Rust also paid close attention to documentation and tests code inside documentation e.g.\ code examples.
    Further is the ability to generate webpages with the documentation build-in which is similar to Python.

    Through the appealing goals and the convenient tooling Rust gained traction over the last years.\autocites{so-survey}{rust-org}{rust3}
    It also sees application in the industry slowly.
    Mozilla's Firefox uses Servo, the \gls{css} Style engine, since the 57 Firefox release.\autocite{servo}
    Other notable companies that are using Rust are Atlassian, Cloudflare
    and Dropbox.\autocite{rust-org}
    While the industry is slowly testing and adopting Rust it has to be said that this language is still young and undergoes radical changes ever so often.

\end{document}
