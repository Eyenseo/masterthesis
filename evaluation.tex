\documentclass[thesis]{subfiles}
\begin{document}

\chapter{Evaluation}\label{chap:eval}
The code, generated from the implemented generator supports all required features of the thesis description.
Additionally the optional features were implemented.
The parallelism -- data race free through the Rust type system -- however could not be achieved.
The following sections will focus on on the reasons for the missing parallelism, the performance impacts from that and lastly a small collection of oddities from Rust.

\section{Parallelism}
  The reason for the missing parallelism in the Rust implementation boils down to the insufficient capabilities of the Rust type system.
  In \autoref{sec:graph} the problem with graph like structures in Rust was explored.
  Then in \autoref{sec:ptr} \PtrT was presented as solution.
  The only possible alternative being an \gls{ecs} like architecture, which was ruled out as being to unsafe to be used in a language like Rust that promises safety.

  The first issue with the wish to parallelize code that uses \PtrT is that \PtrT is reference counting to enforce the borrow rules as well as the lifetime of the managed memory.
  That means that both, the borrowing and the cloning has to happen in an atomic way.
  Paying for an atomic operation for every copy of the reference and at every access is not the worst, but definitely not fast either.
  But the big parallelism benefits can only be gained if the fields of the objects can be initialized in parallel.
  The binary format is designed in such a way that the field data can be read in parallel.
  To support also that kind of parallelism all fields in the objects would have to be enclosed in \RefCellT.
  But that would lead to data races, meaning that every access of the field would have to be guarded by an atomic operation too.
  Not only would that kind of interface be unpleasant to use (three wrappers in total) but it would also mean that there are at least four atomic operations to access a value from a \PtrT instance.
  The first would be the borrow from \PtrT, the second from \RefCellT for the value.
  At some point in time the two borrows would go out of scope and with that the other two atomic operations would happen.
  While these atomic operations make the program seemingly safe and for the de-/serialisation code usable they would pose unexpected behaviour for the user, in addition to be slow.

  Apart from \PtrT the pools would also have to be able to be shared over thread boundaries which would require more atomic operations.
  Since Rusts guarantees for data race free programs stems from the borrowing rules, which are pushed to the runtime since the type system is unable to accommodate graph like structures by the wrappers the main research point is a negative result.
  While it is not impossible to implement the de-/serialisation in a parallelized way the implications make it quite clear that it would be unwise to do so.
  Additionally to a questionable speedup for the de-/serialisation this kind of implementation would force the user to pay through out the whole execution time of the program.

\section{Performance}
  \autoref{fig:bench} shows a comparison of Rust vs C++.
  The displayed data was generated by a python harness that generated the code from the specification of \autocite{skill-llvm}.
  It would then generate a main function that would deserialise, serialize and deserialise a file given as argument (100 repetitions each).
  After compiling all binaries the harness would time the execution of the binaries while supplying data files from \autocite{skill-llvm}.
  Because of memory leaks in the C++ version this setup had to be chosen instead of a more library focused one, where the binary would de-/serialize the file multiple times in the same process.
  On the other hand has the C++ version more features implemented than the Rust version.
  Because of these facts this comparison should be taken with caution but the large divergence of run times indicates that other more fundamental pieces differ.

  \begin{figure}[ht]
    \centering
    \input{data/20mbbench}~\hfill
    \input{data/total_bench}
    \caption{Rust Performance vs C++}\label{fig:bench}
  \end{figure}

  A \cod{perf} analysis didn't show any particular hot spot that could be optimized.
  The code seems to be generally slow which should be expected if every \PtrT instance access requires at least two integer additions for the borrow checking and at least four if it is obtained from a \UserTypePool.
  Since the memory locations, that are pointed to by \PtrT, are not one contiguous piece but fragmented memory locations it is further possible that most accesses lead to a cache miss.
  It can also be assumed that even with a `perfectly' parallelized implementation the speedup of the parallel processing would not be enough to catch up to C++.
  While the C++ single thread version is slower than the multi thread version ($\times 1.4$) the rust version is $\times 3.3$ slower than the single threaded C++ version ($\times 4.6$ slower than the multi thread C++ version).

  While Rust uses LLVM and LLVM can produce \emph{blazingly fast} machine code this thesis can not verify that Rust leads to blazingly fast code.
  The safety aspect of Rust is similarly in question as the community relies on unsafe alternatives (\gls{ecs}) to work with graph like structures in an effort to produce fast code.
  And while it is true that an array out of bounds access will not result in a segfault, it will result in a \codr{panic} which is not much better.
  Similarly is a deadlock in a wrapper for borrow checking at runtime not \emph{thread safe}.
  A fairer assessment of Rust would be to say \enquote{Rust \emph{wants to be} a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.} than that it \emph{is}, as not all goals have been achieved yet or only to a questionable degree.
  \enquote{Like C++, Rust takes zero-cost abstractions as one of its core principles: none of Rustâ€™s abstractions impose a global performance penalty, nor is there overhead from any runtime system in the traditional sense.}\autocite{rust-faq} might be true, but also not completely honest.

\section{Rust Oddities}
  This section will focus on more oddities and questionable design choices that have been encountered while working with Rust.

  \subsection{Immutable File Manipulations}
    A few strange things happen in \autoref{lst:rustfile}.
    The first thing is, that line 8 and 10 produce \emph{not} the same output but different.
    The file is immutable so how can an iterator (\codr{bytes(self)} creates on) change the position of file?
    The only answer that could be found regarding that is from StackOverflow, \enquote{File is basically just a new typed file descriptor, i.e. an index into an open-file table that is managed by the OS. read and friends will not change this descriptor at all, which is why the File does not need to be mutated. There is of course mutation going on, but that is done by the operating system on its own data structures and not in your user-land rust code.}\autocite{so-rust-file}.
    While that does sound at least somewhat reasonable it is shocking that there is no mentioning of this in the documentation or even more important the type system.

    Further how can bytes be called by \codr{(&f)}?
    \codr{(&f)} creates an reference to an immutable file but \codr{bytes(self)} requires an object.
    The thing that is miss understood here is that \trait \Read is not implemented for \File but for \codr{&'a File}.
    Which means that \self is not an object but a reference to one.

    But the real question is the following; How can it be that line 12 fails?
    With the given explanation from the first question, this should be allowed.
    In this case there is really no modification going on too.

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \lstinputlisting[
        style=myEnvStyle,
        language=Rust,
        nolol=ture,
      ]{data/file.rs}
      \caption{File is not Subject to Borrow Rules}\label{lst:rustfile}
    \end{figure}

  \subsection{Static Functions for Traits}
    To implement a static function for a \trait should not be difficult, but it is.
    In \autoref{lst:static} two options are shown how to do it.
    The first option involves functions that are implemented in the \trait without a \self parameter.
    Unfortunately they can't be called on the \trait itself, as seen in line 28.
    The other option uses an extra \trait that is implemented for the trait that should have the static function.

    \newsavebox{\staticOne}
    \begin{lrbox}{\staticOne}
      \begin{minipage}{.47\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
          lastline=12,
        ]{data/static.rs}
      \end{minipage}
    \end{lrbox}

    \newsavebox{\staticTwo}
    \begin{lrbox}{\staticTwo}
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
          firstline=14,
          firstnumber=14,
          lastline=25,
        ]{data/static.rs}
      \end{minipage}
    \end{lrbox}

    \newsavebox{\staticThree}
    \begin{lrbox}{\staticThree}
      \lstinputlisting[
        style=myEnvStyle,
        language=Rust,
        nolol=ture,
        firstline=27,
        firstnumber=27,
      ]{data/static.rs}
    \end{lrbox}

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \usebox{\staticOne}\hfill%
      \usebox{\staticTwo}\\%
      \usebox{\staticThree}
      \caption{Emulated Inheritance with Traits}\label{lst:static}
    \end{figure}

  \subsection{Immutability Resolution}
    Rusts immutability is more or less an on off switch and there is no mechanism to say; `This attribute is immutable' without an extra type that wraps the value.
    So if a object is passed as immutable nothing can be changed, that is not wrapped by a \UnsafeCellT.
    But on the other hand everything can be changed if the object is mutable.
    Coming from a C++ background the lack of the \codc{const} feature reduces the expressiveness greatly.
    And to a certain degree it also influences the safety of the program.

  \subsection{Trait Visibility Requirements}
    \autoref{lst:traitvis} shows a very unfortunate design decision of Rust.
    \codr{trait A} is supposed to expose an \gls{api} to the crate, not intended for the user.
    \codr{trait B} should require \A to be implemented -- which should be legal as no type is leaked outside of the implementation of \B.
    What this would mean is, that the user can work with types that implement \B and that the user can not implement \B for any other type.
    At the moment \codr{trait A} has to be made public as well -- and with that visible and usable for the user.

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \lstinputlisting[
        style=myEnvStyle,
        language=Rust,
        nolol=ture,
      ]{data/traitvis.rs}
      \caption{Trait Visibility Issues}\label{lst:traitvis}
    \end{figure}

  \subsection{Coercion}
    Rusts name for implicit casts is \emph{coercion}.
    Most of the times it does what one would expect it to do.
    But in line 14 of \autoref{lst:coercionOne} the compiler raises an error as \Foo is not \codr{&Foo}.
    And that is strange -- we own the object, it is mutable and if we can write a ref in front of \codr{f} than the compiler should be able to too.

    \autoref{lst:coercionTwo} shows another strange mechanic that is related to coercion.
    Here \A is inherited by \B and \B and \A are implemented for \Foo.
    Then \codr{f} is borrowed as \B and through \codr{b} the function \fun of \A is called.
    But in line 11 the compiler raises an error, informing us that \codr{b} is not of type \codr{a}.

    \newsavebox{\coercionOne}
    \begin{lrbox}{\coercionOne}
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
        ]{data/coercion_1.rs}
      \end{minipage}
    \end{lrbox}

    \newsavebox{\coercionTwo}
    \begin{lrbox}{\coercionTwo}
      \begin{minipage}{.45\linewidth}
        \lstinputlisting[
          style=myEnvStyle,
          language=Rust,
          nolol=ture,
        ]{data/coercion_2.rs}
      \end{minipage}
    \end{lrbox}

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \subfloat[Coercion of Types\label{lst:coercionOne}]{\usebox{\coercionOne}}\hfill%
      \subfloat[Coercion of Traits\label{lst:coercionTwo}]{\usebox{\coercionTwo}}
      \caption{Coercion in Rust}\label{lst:coercion}
    \end{figure}

  \subsection{Helpless Wrapped Values}
    This issue is common to all smart pointer / wrapper but manifests in Rust in a more severe problem.
    If a value of type \T is wrapped e.g. \RcT then no method of \T can pass itself on, as the wrapper is not know.
    Since Rust uses a lot of wrapper types this problem appears more often than in other languages and is only solved thou a method signature of \T that includes `own' \RcT.

  \subsection{Lifetimes}
    Lifetimes are needed for the Rust compiler to verify the compliance with the borrow rules.
    The issue with lifetimes is, that they are not general lifetimes, they are intended exclusively for the borrows and can't be used to specify how long an object may life.
    An example use case for that would be a memory arena where the arena processes a life time and objects that are allocated though the arena would have to be freed before the end of the lifetime of the arena.

    The example from \autoref{lst:match} is about the lifetimes of borrows.
    The function \fun accepts a \Foo reference and if \codr{opt} has a value it should be printed and another function should be called.
    That however is illegal in the current version of Rust -- once non lexical lifetimes are implemented this will compile without error.

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \lstinputlisting[
        style=myEnvStyle,
        language=Rust,
        lastline=11,
        nolol=ture,
      ]{data/match.rs}
      \caption{Self in Matches}\label{lst:match}
    \end{figure}


  \subsection{Iterators and For Loops}
    This oddity, seen in \autoref{lst:iter}, is about the iterators, the for loop and how they interact with each other.
    Lines 1 to 11 implement a iterator that iterates over the numbers 1 to 5.
    In line 14 a \struct \Foo is declared.
    In the \fun function the issue becomes apparent -- line 17 doesn't compile.
    The reason for that is that \for consumes an iterator and that can't happen from a borrow.
    To work around that the loop from lines 18 to 23 can be used.

    \begin{figure}[ht]
      \captionsetup{type=lstlisting}
      \lstinputlisting[
        style=myEnvStyle,
        language=Rust,
        lastline=25,
        nolol=ture,
      ]{data/iter.rs}
      \caption{Iterators in For Loops}\label{lst:iter}
    \end{figure}

    %\subsection{Borrowing}
    % FIXME Cant come up with a MWE
    %* Rust borrowing ...
    %  * Illegal
    %    ```
    %    let mut map = HashMap::default();
    %    map.reserve(1);
    %    map.insert(sf.strings.borrow_mut().add("hallo"), {
    %        let mut map = HashMap::default();
    %        map.reserve(1);
    %        map.insert(None, sf.strings.borrow_mut().add("welt"));
    %        map
    %    });
    %    map
    %    ```
    %  * Legal
    %    ```
    %    let mut map = HashMap::default();
    %    map.reserve(1);
    %    map.insert({
    %        let mut sp = sf.strings.borrow_mut();
    %        let s = sp.add("hallo");
    %        s
    %    }, {
    %        let mut map = HashMap::default();
    %        map.reserve(1);
    %        map.insert(None, {
    %            let mut sp = sf.strings.borrow_mut();
    %            let s = sp.add("welt");
    %            s
    %        });
    %        map
    %    });
    %    map
    %    ```
    % * Legal
    %    ```
    %      {
    %        let mut sp = sf.strings.borrow_mut();
    %        sp.add("welt")
    %      }
    %    ```
    %    * Illegal
    %    ```
    %      {
    %        sf.strings.borrow_mut().add("welt")
    %      }
    %    ```
    %    * Illegal
    %    ```
    %      sf.strings.borrow_mut().add("welt")
    %    ```
    %* mention this shit
    %    ```
    %    let mut super_pool = super_pool.upgrade().unwrap();
    %    let mut super_pool = super_pool.borrow_mut();
    %    let mut super_pool = super_pool.pool_mut();
    %    ```

\section{\glsentrytext{skill} Improvements}
  There is not much functional room for improvement that came apparent in this thesis.
  The one thing that could be improved in a new specification would be that annotation fields do not have to use two byes to signal that the annotation is \codc{NULL}.
  Currently the pool id and object id is given and set to 0 but since there can't be a pool with id 0 the additional byte for the object id can be saved.

  Another improvement that was made to the Rust and C++ implementation is the offset calculation in regards to the variable length integers.
  The previous implementation checked the continuation bit by using bit masks but since these languages support unsigned integer the comparison and masking can be replaced by a simple smaller than comparison.

\end{document}
